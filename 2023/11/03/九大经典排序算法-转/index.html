<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"luckyeast.eu.org","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="概述排序的复杂度一览   算法 时间复杂度:最好 时间复杂度:平均 时间复杂度:最坏 空间复杂度:最坏 稳定性    冒泡排序 O(n) O(n^2) O(n^2) O(1) 稳定   选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定   插入排序 O(n) O(n^2) O(n^2) O(1) 稳定   希尔排序 O(n) O(n^3&#x2F;2) O(n^2) O(1)"><meta property="og:type" content="article"><meta property="og:title" content="九大经典排序算法[转]"><meta property="og:url" content="https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/index.html"><meta property="og:site_name" content="LuckyEast&#39;s Blog"><meta property="og:description" content="概述排序的复杂度一览   算法 时间复杂度:最好 时间复杂度:平均 时间复杂度:最坏 空间复杂度:最坏 稳定性    冒泡排序 O(n) O(n^2) O(n^2) O(1) 稳定   选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定   插入排序 O(n) O(n^2) O(n^2) O(1) 稳定   希尔排序 O(n) O(n^3&#x2F;2) O(n^2) O(1)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://luckyeast.eu.org/images/pasted-1.png"><meta property="article:published_time" content="2023-11-03T05:47:00.000Z"><meta property="article:modified_time" content="2023-11-07T06:04:02.829Z"><meta property="article:author" content="LuckyEast"><meta property="article:tag" content="算法"><meta property="article:tag" content="编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://luckyeast.eu.org/images/pasted-1.png"><link rel="canonical" href="https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/","path":"2023/11/03/九大经典排序算法-转/","title":"九大经典排序算法[转]"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>九大经典排序算法[转] | LuckyEast's Blog</title><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">LuckyEast's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">永远年轻，永远热泪盈眶</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%80%E8%A7%88"><span class="nav-text">排序的复杂度一览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-time-complexity"><span class="nav-text">时间复杂度(time complexity)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Space-Complexity"><span class="nav-text">空间复杂度(Space Complexity)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">排序的稳定性</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="nav-text">冒泡排序(Bubble Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort"><span class="nav-text">选择排序(Selection Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-1"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-1"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="nav-text">插入排序(Insertion Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-2"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-2"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shell-Sort"><span class="nav-text">希尔排序(Shell Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-3"><span class="nav-text">核心思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-3"><span class="nav-text">代码讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-3"><span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="nav-text">复杂度分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="nav-text">快速排序(Quick Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-4"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-4"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-4"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="nav-text">归并排序(Merge Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-5"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-5"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-5"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-Counting-Sort"><span class="nav-text">计数排序(Counting Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-6"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-6"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="nav-text">基数排序(Radix Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-7"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-7"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-6"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="nav-text">堆排序(Heap Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-text">相关概念：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-8"><span class="nav-text">核心思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-8"><span class="nav-text">代码讲解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-7"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="nav-text">复杂度分析</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="LuckyEast" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">LuckyEast</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="LuckyEast"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LuckyEast's Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="九大经典排序算法[转] | LuckyEast's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">九大经典排序算法[转]</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-11-03 13:47:00" itemprop="dateCreated datePublished" datetime="2023-11-03T13:47:00+08:00">2023-11-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-11-07 14:04:02" itemprop="dateModified" datetime="2023-11-07T14:04:02+08:00">2023-11-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="排序的复杂度一览"><a href="#排序的复杂度一览" class="headerlink" title="排序的复杂度一览"></a>排序的复杂度一览</h4><table><thead><tr><th align="center">算法</th><th align="center">时间复杂度:最好</th><th align="center">时间复杂度:平均</th><th align="center">时间复杂度:最坏</th><th align="center">空间复杂度:最坏</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">插入排序</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n)</td><td align="center">O(n^3&#x2F;2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n^2)</td><td align="center">O(logn)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(k)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr></tbody></table><span id="more"></span><h4 id="时间复杂度-time-complexity"><a href="#时间复杂度-time-complexity" class="headerlink" title="时间复杂度(time complexity)"></a>时间复杂度(time complexity)</h4><p>用来描述算法的运行时间。常用大 O 符号表述。比如：O(n)，O(1)，O(logn)，O(n^2)等。举例： O(n)表示线性级复杂度，表示时间复杂度和元素 element 数量 n 成正比。比如数组的线性查找的复杂度随着元素数量增加而增加。 O(1)表示常数级复杂度，表示时间复杂度不随元素 element 数量变化而变化。比如链表的插入的复杂度不随链表节点数量变化而变化。 其他常见的复杂度如下图所示：</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><h4 id="空间复杂度-Space-Complexity"><a href="#空间复杂度-Space-Complexity" class="headerlink" title="空间复杂度(Space Complexity)"></a>空间复杂度(Space Complexity)</h4><p>对一个算法在运行过程中临时占用存储空间大小的量度。也可用大 O 符号表述。举例： O(n)表示线性级复杂度，表示算法所需空间大小和元素数量成正比，比如归并排序，需要额外的临时空间来保存两个数组的合并结果，元素越多所需空间越大。 O(n)表示常数级复杂度，表示算法所需空间大小和元素数量无关。</p><h4 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h4><p>稳定：相等的两个数，排序前后两数的顺序保持不变。<br>不稳定：相等的两个数，排序前后两数的顺序发生变化。</p><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组分为左右两部分，左为无序部分，右为有序部分。无序部分中的最大数在每次遍历结束后被交换到无序部分的最右侧，继而成为有序部分的最左侧元素，就像冒泡一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    for i in 0..&lt;n-1 &#123;</span><br><span class="line">        var isSorted = true</span><br><span class="line">        for j in 0..&lt;n-1-i &#123;</span><br><span class="line">            if a[j] &gt; a[j+1] &#123;</span><br><span class="line">                a.swapAt(j, j+1)</span><br><span class="line">                isSorted = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if isSorted &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>使用双重循来遍历，把双重循环分为内循环和外循环。</p><ul><li>内循环： 从左往右处理无序部分，使用下标 j 遍历，比较相邻元素大小，交换位置成为左小右大，一次遍历后，无序部分中最大数被交换到无序部分的最右处，继而加入有序部分的最左侧。</li><li>外循环： i 可理解为有序部分的数量，每次内循环结束，有序部分数量增加一个，无序部分数量减少一个。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>两两比较，不存在跳跃，所以稳定。 每次遍历都能检查数组是否有序，可提前退出排序，但是冒泡的交换在内循环，交换次数多。实际效率比选择排序低。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最好的情况可以达到 O(n)，最坏的情况是 O(n^2)，平均 O(n^2)。</p><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组分为左右两部分，左为有序部分，右为无序部分。无序部分每次遍历选择出一个最小的元素，交换到无序部分的最左侧，继而成为有序部分的最右侧元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    for i in 0..&lt;n-1 &#123;</span><br><span class="line">        var iMin = i</span><br><span class="line">        for j in i+1..&lt;n &#123;</span><br><span class="line">            if a[iMin] &gt; a[j] &#123;</span><br><span class="line">                iMin = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.swapAt(i, iMin)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-1"><a href="#代码讲解-1" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>使用双重循来遍历，把双重循环分为内循环和外循环。</p><ul><li>内循环： 从左往右处理无序部分，使用下标 j 遍历，每次遍历后保存下无序部分中最小数的位置 iMin 。</li><li>外循环： i 为无序部分的首元素位置，其左侧为有序部分，将有序部分排除在内循环外。每次内循环结束，将内循环保存的 iMin 和 i 位置的连个元素交换，使有序部分数量增加一个，无序部分数量减少一个。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>由于交换动作放在外循环，交换次数少于冒泡，实际效率优于冒泡。除非本来就是有序的数组的最好情况，选择排序还是要进行比较和交换，而冒泡排序一次 n 的遍历就能提前退出。 不稳定，举个例子，序列 5 8 5 2 9 ， 我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了）</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最好情况 O(n^2)，最坏情况 O(n^2)，平均 O(n^2)。</p><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><h4 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组分为左右两部分，左为有序部分，右为无序部分。遍历有序部分，将无序部分首元素，根据其大小在有序部分寻找合适的位置并插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    for i in 1..&lt;n &#123;</span><br><span class="line">        print(&quot; i=\(i)&quot;)</span><br><span class="line">        let value = a[i]</span><br><span class="line">        var hole = i</span><br><span class="line">        while hole &gt; 0 &amp;&amp; a[hole-1] &gt; value &#123;</span><br><span class="line">            a[hole] = a[hole-1]</span><br><span class="line">            hole -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-2"><a href="#代码讲解-2" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>使用双重循来遍历，把双重循环分为内循环和外循环。</p><ul><li>内循环： 每次从无序部分的首元素 value 的位置开始，从右向左，在有序部分中遍历，比较每一个元素，凡是比 value 大的元素，都向右移动一位，遍历结束后空出来的位置 hole 就是 value 的插入位置。</li><li>外循环： i 可理解为有序部分的数量，同时也是无序部分的首元素的位置。每次外循环 value 都作为无序部分首元素，需通过内循环在有序部分寻找一个合适的位置 hole 并将其插入。</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>选择排序的比较开销是固定的 n(n-1)&#x2F;2,而插入排序平均下来是 n(n-1)&#x2F;4 。 选择排序最多只需要执行 2(n-1)次交换，而插入排序平均的交换开销也是 n(n-1)&#x2F;4 。这就取决于单次比较和交换的开销之比。如果是一个量级的，则插入排序优于选择排序，如果交换开销远大于插入开销，则插入排序可能比选择排序慢。 两两比较，不存在跳跃，所以稳定。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最好情况 O(n)，最坏情况 O(n^2)，平均 O(n^2)。</p><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><h4 id="核心思路-3"><a href="#核心思路-3" class="headerlink" title="核心思路"></a>核心思路</h4><p>在插入排序基础上引入增量 gap 概念，是插入排序的改进。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    var gap = n / 2</span><br><span class="line">    while gap &gt; 0 &#123;</span><br><span class="line">        for i in gap..&lt;n &#123;</span><br><span class="line">            let value = a[i]</span><br><span class="line">            var hole = i</span><br><span class="line">            while hole &gt; 0 &amp;&amp; a[hole-1] &gt; value &#123;</span><br><span class="line">                a[hole] = a[hole-1]</span><br><span class="line">                hole -= 1</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = value</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码讲解-3"><a href="#代码讲解-3" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>当增量 gap 为半数时，在整个数组中选取右边 1&#x2F;2 部分进行插入排序，在此结果上在整个数组中选取右边 3&#x2F;4 部分进行插入排序，反复这个过程，直到最后一次对整个数组做插入排序，最终成为有序数组。 每次做插入排序的部分从 gap 开始，每次扩大做插入排序的范围。</p><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>希尔排序算法 1959 年提出，是直接插入排序算法的一种改进，减少了移动次数，平均时间复杂度比插入快。是第一批时间复杂度低于 O(n^2)的排序算法。 插入排序是稳定的，而 shell 排序会分组，相同的数分在不同的组内各自进行移动打破稳定性。所以不稳定。</p><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>gap &#x2F;&#x3D; 2 表示折半的方式选取增量。究竟应该选取什么样的增量才是最好，目前还有数学上的定论。最坏的情况是 O(n^2)，在使用了增量后，平均时间复杂度 O(n^(3&#x2F;2))。</p><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h2><h4 id="核心思路-4"><a href="#核心思路-4" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组最右侧的元素作为一个参照值 pivot，以参照值为标准，将数组拆分 patition 为 3 个部分：比参照值小的部分，参照值，比参照值大的部分。 将这个过程再分别应用到较小部分和较大部分中继续拆分，直到所有部分被拆分成 1 个元素无法再拆分，就完成了排序。 这是一个分而治之的方法，也是一个递归的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;, start: Int, end: Int)&#123;</span><br><span class="line">    if start &lt; end &#123;</span><br><span class="line">        let partitionIndex = partition(&amp;a, start: start, end: end)</span><br><span class="line">        sort(&amp;a, start: start, end: partitionIndex-1 )</span><br><span class="line">        sort(&amp;a, start: partitionIndex+1, end: end )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func partition(_ a:inout Array&lt;Int&gt;, start: Int, end: Int) -&gt; Int &#123;</span><br><span class="line">    let pivot = a[end]</span><br><span class="line">    var partitionIndex = start</span><br><span class="line">    for i in start..&lt;end &#123;</span><br><span class="line">        if a[i] &lt;= pivot &#123;</span><br><span class="line">            a.swapAt(i, partitionIndex)</span><br><span class="line">            partitionIndex += 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.swapAt(partitionIndex, end)</span><br><span class="line">    return partitionIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-4"><a href="#代码讲解-4" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>每次递归将数组拆分成前部，基准值，后部 3 部分，前部比后部小。按此方法再递归调用前，后部分，最终达到从小到大的排序。</p><p>partition()拆分 将数组 a 的 start 到 end 区间拆分为三部分。区间内选择一个参照值，通常可选 start 或者 end 的值为参照。因为区间拆分前无序，任何一个值都可作为参照，这里我们选择 end 的值作为参照值 pivot 。 因为 pivot 作为 end ，所以区间遍历使用 i 从 start 到 end-1 ，并假设参照值位置为 pt 初始为 start 。将比参照值小的元素交换到 pt ，pt 的右侧位置就是参照值的位置，所以 pt+&#x3D;1 ，遍历结束，将参照值交换到 pt ，并返回参照值的位置。<br>sort()递归分治 调用 partition()拆分数组，返回拆分后参照值位置 pt ，那么数组前部分的区间是 start 到 pt-1 ，后部分的区间为 pt+1 到 end 。对着两部分继续递归调用 sort()。当数组被拆分为 1 个元素，即 start 等于 end 的时候，则停止分治，退出递归。</p><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>快速排序是一种交换类的排序，它同样是分治法的经典体现。 如果 pivot 的值有重复，pivot 作为参照放在前后两部中间有可能打破稳定性，所以不稳定。</p><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>待排序数组最终被拆分成深度为 logn+1 的二叉树。拆分次数为 logn 。第一次拆分时，总共的执行时间是 Cn(C 为固定的单位时间常数)；第二次拆分时，每个子序列的执行时间为 Cn&#x2F;2 ，总的执行时间是 Cn&#x2F;2+Cn&#x2F;2&#x3D;Cn ；第三次拆分时，总时间时 Cn&#x2F;4+Cn&#x2F;4+Cn&#x2F;4+Cn&#x2F;4+&#x3D;Cn ，所以每次执行复杂度都是 Cn 。 每次执行复杂度 Cn * 拆分次数 log(n) &#x3D; 快排复杂度 O(nlogn)。最坏情况 O(n^2)。</p><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h2><h4 id="核心思路-5"><a href="#核心思路-5" class="headerlink" title="核心思路"></a>核心思路</h4><p>将两个有序数组，合并为一个新的有序数组就是做归并。 归并排序中，将数组从中间分解为左右两部分，将这个过程再应用到左右部分中继续分解。最后把 n 个元素的数组分解为只有 1 个元素的 n 个数组。这种情况下，满足两个有序数组进行的归并条件，开始再两两归并，直到合并出一个新的有序数组就完成了排序。 这是一个分而治之的方法，同时也是一个递归的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func sort(a: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    if n == 1 &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    var left = Array(a[0..&lt;n/2])</span><br><span class="line">    var right = Array(a[n/2..&lt;n])</span><br><span class="line">    left = sort(a: left)</span><br><span class="line">    right = sort(a: right)</span><br><span class="line">    let m = merge(left: left, right: right)</span><br><span class="line">    return m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(left: [Int], right: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    var mergedList = [Int]()</span><br><span class="line">    while left.count &gt; 0 &amp;&amp; right.count &gt; 0 &#123;</span><br><span class="line">        if left.first! &lt; right.first! &#123;</span><br><span class="line">            mergedList.append(left.first!)</span><br><span class="line">            left.removeFirst()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mergedList.append(right.first!)</span><br><span class="line">            r.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mergedList + left + right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-5"><a href="#代码讲解-5" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>sort()将数组 a 从中间分为 left 和 right 两部分。再将 left 和 right 再递归调用 sort 继续分解。将分解的结果传入 merge()进行归并。<br>merge()合并 left 和 right 两个有序数组，返回合并后的有序数组。将 left 和 right 两个数组同时开始遍历，对比两个数组的首元素，将较小的元素填入 mergedList ，并在原数组中删除。当遍历结束后，left 或 right 还不为空，说明该数组元素都大于 mergedList ，加入在 mergedList 尾部即可。</p><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p>该算法采用经典的分治（ divide-and-conquer ）策略。分治法将问题分(divide)成一些小的问题然后递归求解。两两比较，不存在跳跃，所以稳定。</p><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>归并排序的效率是比较高的，设数列长为 n ，将数列分开成小数列一共要 logn 步，每步都是一个合并有序数列的过程，时间复杂度可以记为 O(n)，故一共为 O(nlogn)。对空间有要求，空间复杂度 O(n)。所以，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p><h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h2><h4 id="核心思路-6"><a href="#核心思路-6" class="headerlink" title="核心思路"></a>核心思路</h4><p>通过前面元素出现的累计次数确定当前元素的位置，比如第一个元素 1 出现 3 次，那么元素 2 的位置从第 4 个开始，元素 2 出现 4 次，那么元素 3 的位置从第 8 个开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;) &#123;</span><br><span class="line">    let max = a.max() ?? 0</span><br><span class="line">    let min = a.min() ?? 0</span><br><span class="line">    let k = max - min + 1</span><br><span class="line">    var counts = [Int](repeating: 0, count: k)</span><br><span class="line">    for item in a &#123;</span><br><span class="line">        let i =  item - min</span><br><span class="line">        counts[i] += 1</span><br><span class="line">    &#125;</span><br><span class="line">    var prefixSums: [Int] = counts</span><br><span class="line">    for i in 1..&lt;counts.count &#123;</span><br><span class="line">        prefixSums[i] = prefixSums[i - 1] + counts[i]</span><br><span class="line">    &#125;</span><br><span class="line">    var sorted = [Int](repeating: 0, count: a.count)</span><br><span class="line">    for i in 0..&lt;a.count &#123;</span><br><span class="line">        let key = a[i]</span><br><span class="line">        let index = key - min</span><br><span class="line">        let prefixSum = prefixSums[index]</span><br><span class="line">        sorted[prefixSum - 1] = key</span><br><span class="line">        prefixSums[index] -= 1</span><br><span class="line">    &#125;</span><br><span class="line">    a = sorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-6"><a href="#代码讲解-6" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>在无序数组中，先找出最大值 max 和最小值 min ，从而确定需要开辟 max-min+1 大小空间的计数数组和累计数组。</p><p>计数数组： 保存每个元素出现的次数。比如 1 出现 2 次，2 出现 3 次。<br>累计数组： 保存前面元素累计出现的次数。比如，1 出现 3 次，累计 3 次； 2 出现 4 次，累计 3+4&#x3D;7 次； 3 出现 1 次，累计 7+1&#x3D;8 次。累计次数-1 就是元素有序的位置。<br>特点</p><p>计数排序是一个稳定的非比较排序算法。它的优势在于在对一定范围内的整数排序，比如对 1 万名学生的考试分数做排序。计数排序是一种以空间换时间的排序算法，整数大小差异越大，所需要的空间越大。</p><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>计数数组的大小为 k ，无序数组大小为 n ，复杂度为Ο(n+k)，所以时间复杂度是 O(n)；由于申请了大小为 k 的桶来放计数，所以空间复杂度是 O(k)。</p><h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h2><h4 id="核心思路-7"><a href="#核心思路-7" class="headerlink" title="核心思路"></a>核心思路</h4><p>是一种非比较的整数排序算法。其原理是将整数按位数切割成不同的数字，然后对每个位数上的数字进行分别比较。第一轮先按个位数大小排序，第二轮按十位数大小排序，一直进行到最高位。实际上是也一种桶排序，从 0 到 9 一共分 10 个桶。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let maxValue = a.max() ?? 0</span><br><span class="line">    var buckets = [[Int]](repeating: [], count: 10)</span><br><span class="line">    var powerOfTen = 1</span><br><span class="line">    while maxValue / powerOfTen &gt; 0 &#123;</span><br><span class="line">        a = a.compactMap &#123; value in</span><br><span class="line">            buckets[value / powerOfTen % 10].append(value)</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        buckets = buckets.map &#123; bucket in</span><br><span class="line">            bucket.forEach &#123; value in</span><br><span class="line">                a.append(value)</span><br><span class="line">            &#125;</span><br><span class="line">            return []</span><br><span class="line">        &#125;</span><br><span class="line">        powerOfTen *= 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-7"><a href="#代码讲解-7" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>先找到最大数，算出最大数有几位，则进行几次桶排序。 powerOfTen 初始为 1 ，每次 while 循环则乘以 10 倍，这样 while 循环的次数就是最大数的位数。 10 个桶，当进行个位数比较的时候，桶 n 保存个位为 n 的元素，当进行十位数比较的时候，桶 n 保存十位为 n 的元素。</p><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>是一种非比较的稳定的整数排序算法。 不适用于数字的位数 k 多，但是排序的数少的情况； 适用于数字小但是排序的数字多的情况。</p><h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>复杂度是 O(n*k)。其中 n 是排序元素个数，每轮处理的操作数目； k 是数字位数，决定了进行多少轮处理。 并不一定优于 O(n·logn)，当 k&gt;logn ，就没有归并、堆排序快。</p><h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h2><h4 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h4><p>完全二叉树：其每个结点的编号跟满二叉树都能一一对应。<br>堆：是一个完全二叉树，其每个结点的值都大于等于其子结点的值称为大顶堆。<br>满二叉树：所有分支结点都有左右子结点，所有子结点都在同一层上。</p><h4 id="核心思路-8"><a href="#核心思路-8" class="headerlink" title="核心思路"></a>核心思路</h4><p>大顶堆的顶是最大的，所以堆排序的过程就是反复的构造堆。 第一次构建的堆顶最大，和堆尾交换放在数组最后一位，第二次构建的堆的堆顶第二大，放在倒数第二位，以此类推进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">	// 构建初始堆</span><br><span class="line">    createHeap(a: &amp;a)</span><br><span class="line">    // 重建堆。逆序遍历反复构建大顶堆，遍历一次，顶被摘掉放入结果数组 a 尾部，直到最后无法构建堆，结果就是有序数组 a</span><br><span class="line">    for index in a.indices.reversed() &#123;</span><br><span class="line">        siftDown(from: 0, upTo: index, a: &amp;a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createHeap(a:inout Array&lt;Int&gt;) &#123;</span><br><span class="line">    if !a.isEmpty &#123;</span><br><span class="line">        //从 a.count/2 - 1 开始到 0 结束，逆序遍历。a.count/2 - 1 是第一个非叶子节点，向根部遍历</span><br><span class="line">        for i in stride(from: a.count/2 - 1, through: 0, by: -1) &#123;</span><br><span class="line">            siftDown(from: i, upTo: a.count, a: &amp;a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func siftDown(from index: Int, upTo size: Int, a:inout Array&lt;Int&gt;) &#123;</span><br><span class="line">    var parent = index</span><br><span class="line">    while true &#123;</span><br><span class="line">        let left = a[leftChildIndex(ofParentAt: parent)]</span><br><span class="line">        let right = a[rightChildIndex(ofParentAt: parent)]</span><br><span class="line">        var candidate = parent</span><br><span class="line">        if left &lt; size &amp;&amp; a[left] &gt; a[candidate] &#123;</span><br><span class="line">            candidate = left</span><br><span class="line">        &#125;</span><br><span class="line">        if right &lt; size &amp;&amp; a[right] &gt; a[candidate] &#123;</span><br><span class="line">            candidate = right</span><br><span class="line">        &#125;</span><br><span class="line">        if candidate == parent &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        a.swapAt(parent, candidate)</span><br><span class="line">        parent = candidate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在树的顺序存储中，返回 i 的左子节点的下标</span><br><span class="line">func leftChildIndex(ofParentAt i: Int) -&gt; Int &#123;</span><br><span class="line">    return (2 * i) + 1</span><br><span class="line">&#125;</span><br><span class="line">// 在树的顺序存储中，返回 i 的右子节点的下标</span><br><span class="line">func rightChildIndex(ofParentAt i: Int) -&gt; Int &#123;</span><br><span class="line">    return (2 * i) + 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-8"><a href="#代码讲解-8" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>先构建堆，可以是大顶堆（也可以是小顶堆）。交换堆顶[0]元素（堆中最大）与末尾[index]元素，再将[0 ，–index]的堆调整为大顶堆。重复到 index 为 0 。</p><h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><p>堆尾如果有重复，被交换到数组首再构建堆，会打破稳定性，所以不稳定（记录的比较和交换是跳跃式进行的）。</p><h4 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>整体主要由构建初始堆和重建堆两部分组成。其中构建初始堆经推导复杂度为 O(n)，在交换并重建堆的过程中，需交换 n-1 次；而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为 nlogn 。所以堆排序时间复杂度一般认为就是 O(nlogn)级。，空间复杂度是 O(1)。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/2023/11/03/Hexo%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/" rel="next" title="Hexo后台运行">Hexo后台运行 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">LuckyEast</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">43k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">39 分钟</span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("11/1/2023 09:30:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>