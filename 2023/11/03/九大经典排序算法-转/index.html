<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="概述排序的复杂度一览   算法 时间复杂度:最好 时间复杂度:平均 时间复杂度:最坏 空间复杂度:最坏 稳定性    冒泡排序 O(n) O(n^2) O(n^2) O(1) 稳定   选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定   插入排序 O(n) O(n^2) O(n^2) O(1) 稳定   希尔排序 O(n) O(n^3&#x2F;2) O(n^2) O(1)"><meta property="og:type" content="article"><meta property="og:title" content="九大经典排序算法[转]"><meta property="og:url" content="https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/index.html"><meta property="og:site_name" content="Hello world"><meta property="og:description" content="概述排序的复杂度一览   算法 时间复杂度:最好 时间复杂度:平均 时间复杂度:最坏 空间复杂度:最坏 稳定性    冒泡排序 O(n) O(n^2) O(n^2) O(1) 稳定   选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定   插入排序 O(n) O(n^2) O(n^2) O(1) 稳定   希尔排序 O(n) O(n^3&#x2F;2) O(n^2) O(1)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://luckyeast.eu.org/images/pasted-1.png"><meta property="article:published_time" content="2023-11-03T05:47:32.000Z"><meta property="article:modified_time" content="2023-11-03T06:11:29.779Z"><meta property="article:author" content="LuckyEast"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://luckyeast.eu.org/images/pasted-1.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><title>九大经典排序算法[转]</title><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.0.0"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" aria-label="顶部" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a href="/archives/">归档</a></li><li><a href="/">项目</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="下一篇" href="/2023/11/02/Linux%E4%B8%8B%E5%BC%80%E6%9C%BA%E6%B7%BB%E5%8A%A0Hosts%E8%AE%B0%E5%BD%95/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="返回顶部" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">上一篇</span> <span id="i-next" class="info" style="display:none">下一篇</span> <span id="i-top" class="info" style="display:none">返回顶部</span> <span id="i-share" class="info" style="display:none">分享文章</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&text=九大经典排序算法[转]"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&is_video=false&description=九大经典排序算法[转]"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=九大经典排序算法[转]&body=Check out this article: https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&name=九大经典排序算法[转]&description="><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&t=九大经典排序算法[转]"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%80%E8%A7%88"><span class="toc-number">1.0.1.</span> <span class="toc-text">排序的复杂度一览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-time-complexity"><span class="toc-number">1.0.2.</span> <span class="toc-text">时间复杂度(time complexity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Space-Complexity"><span class="toc-number">1.0.3.</span> <span class="toc-text">空间复杂度(Space Complexity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.0.4.</span> <span class="toc-text">排序的稳定性</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="toc-number">2.</span> <span class="toc-text">冒泡排序(Bubble Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">2.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort"><span class="toc-number">3.</span> <span class="toc-text">选择排序(Selection Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-1"><span class="toc-number">3.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">3.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">3.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="toc-number">4.</span> <span class="toc-text">插入排序(Insertion Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-2"><span class="toc-number">4.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">4.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">4.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shell-Sort"><span class="toc-number">5.</span> <span class="toc-text">希尔排序(Shell Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-3"><span class="toc-number">5.0.1.</span> <span class="toc-text">核心思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-3"><span class="toc-number">5.1.</span> <span class="toc-text">代码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">5.1.1.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="toc-number">6.</span> <span class="toc-text">快速排序(Quick Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-4"><span class="toc-number">6.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-4"><span class="toc-number">6.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">6.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">6.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="toc-number">7.</span> <span class="toc-text">归并排序(Merge Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-5"><span class="toc-number">7.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-5"><span class="toc-number">7.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">7.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-number">7.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-Counting-Sort"><span class="toc-number">8.</span> <span class="toc-text">计数排序(Counting Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-6"><span class="toc-number">8.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-6"><span class="toc-number">8.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-number">8.0.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="toc-number">9.</span> <span class="toc-text">基数排序(Radix Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-7"><span class="toc-number">9.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-7"><span class="toc-number">9.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-number">9.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="toc-number">9.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="toc-number">10.</span> <span class="toc-text">堆排序(Heap Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">10.0.1.</span> <span class="toc-text">相关概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-8"><span class="toc-number">10.0.2.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-8"><span class="toc-number">10.0.3.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-7"><span class="toc-number">10.0.4.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="toc-number">10.0.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">九大经典排序算法[转]</h1><div class="meta"><span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-name" itemprop="name">LuckyEast</span></span><div class="postdate"><time datetime="2023-11-03T05:47:32.000Z" class="dt-published" itemprop="datePublished">2023-11-03</time></div></div></header><div class="content e-content" itemprop="articleBody"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="排序的复杂度一览"><a href="#排序的复杂度一览" class="headerlink" title="排序的复杂度一览"></a>排序的复杂度一览</h4><table><thead><tr><th align="center">算法</th><th align="center">时间复杂度:最好</th><th align="center">时间复杂度:平均</th><th align="center">时间复杂度:最坏</th><th align="center">空间复杂度:最坏</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">插入排序</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n)</td><td align="center">O(n^3&#x2F;2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n^2)</td><td align="center">O(logn)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(k)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr></tbody></table><h4 id="时间复杂度-time-complexity"><a href="#时间复杂度-time-complexity" class="headerlink" title="时间复杂度(time complexity)"></a>时间复杂度(time complexity)</h4><p>用来描述算法的运行时间。常用大 O 符号表述。比如：O(n)，O(1)，O(logn)，O(n^2)等。举例： O(n)表示线性级复杂度，表示时间复杂度和元素 element 数量 n 成正比。比如数组的线性查找的复杂度随着元素数量增加而增加。 O(1)表示常数级复杂度，表示时间复杂度不随元素 element 数量变化而变化。比如链表的插入的复杂度不随链表节点数量变化而变化。 其他常见的复杂度如下图所示：</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><h4 id="空间复杂度-Space-Complexity"><a href="#空间复杂度-Space-Complexity" class="headerlink" title="空间复杂度(Space Complexity)"></a>空间复杂度(Space Complexity)</h4><p>对一个算法在运行过程中临时占用存储空间大小的量度。也可用大 O 符号表述。举例： O(n)表示线性级复杂度，表示算法所需空间大小和元素数量成正比，比如归并排序，需要额外的临时空间来保存两个数组的合并结果，元素越多所需空间越大。 O(n)表示常数级复杂度，表示算法所需空间大小和元素数量无关。</p><h4 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h4><p>稳定：相等的两个数，排序前后两数的顺序保持不变。<br>不稳定：相等的两个数，排序前后两数的顺序发生变化。</p><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组分为左右两部分，左为无序部分，右为有序部分。无序部分中的最大数在每次遍历结束后被交换到无序部分的最右侧，继而成为有序部分的最左侧元素，就像冒泡一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    for i in 0..&lt;n-1 &#123;</span><br><span class="line">        var isSorted = true</span><br><span class="line">        for j in 0..&lt;n-1-i &#123;</span><br><span class="line">            if a[j] &gt; a[j+1] &#123;</span><br><span class="line">                a.swapAt(j, j+1)</span><br><span class="line">                isSorted = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if isSorted &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>使用双重循来遍历，把双重循环分为内循环和外循环。</p><ul><li>内循环： 从左往右处理无序部分，使用下标 j 遍历，比较相邻元素大小，交换位置成为左小右大，一次遍历后，无序部分中最大数被交换到无序部分的最右处，继而加入有序部分的最左侧。</li><li>外循环： i 可理解为有序部分的数量，每次内循环结束，有序部分数量增加一个，无序部分数量减少一个。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>两两比较，不存在跳跃，所以稳定。 每次遍历都能检查数组是否有序，可提前退出排序，但是冒泡的交换在内循环，交换次数多。实际效率比选择排序低。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最好的情况可以达到 O(n)，最坏的情况是 O(n^2)，平均 O(n^2)。</p><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组分为左右两部分，左为有序部分，右为无序部分。无序部分每次遍历选择出一个最小的元素，交换到无序部分的最左侧，继而成为有序部分的最右侧元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    for i in 0..&lt;n-1 &#123;</span><br><span class="line">        var iMin = i</span><br><span class="line">        for j in i+1..&lt;n &#123;</span><br><span class="line">            if a[iMin] &gt; a[j] &#123;</span><br><span class="line">                iMin = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.swapAt(i, iMin)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-1"><a href="#代码讲解-1" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>使用双重循来遍历，把双重循环分为内循环和外循环。</p><ul><li>内循环： 从左往右处理无序部分，使用下标 j 遍历，每次遍历后保存下无序部分中最小数的位置 iMin 。</li><li>外循环： i 为无序部分的首元素位置，其左侧为有序部分，将有序部分排除在内循环外。每次内循环结束，将内循环保存的 iMin 和 i 位置的连个元素交换，使有序部分数量增加一个，无序部分数量减少一个。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>由于交换动作放在外循环，交换次数少于冒泡，实际效率优于冒泡。除非本来就是有序的数组的最好情况，选择排序还是要进行比较和交换，而冒泡排序一次 n 的遍历就能提前退出。 不稳定，举个例子，序列 5 8 5 2 9 ， 我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了）</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最好情况 O(n^2)，最坏情况 O(n^2)，平均 O(n^2)。</p><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><h4 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组分为左右两部分，左为有序部分，右为无序部分。遍历有序部分，将无序部分首元素，根据其大小在有序部分寻找合适的位置并插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    for i in 1..&lt;n &#123;</span><br><span class="line">        print(&quot; i=\(i)&quot;)</span><br><span class="line">        let value = a[i]</span><br><span class="line">        var hole = i</span><br><span class="line">        while hole &gt; 0 &amp;&amp; a[hole-1] &gt; value &#123;</span><br><span class="line">            a[hole] = a[hole-1]</span><br><span class="line">            hole -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-2"><a href="#代码讲解-2" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>使用双重循来遍历，把双重循环分为内循环和外循环。</p><ul><li>内循环： 每次从无序部分的首元素 value 的位置开始，从右向左，在有序部分中遍历，比较每一个元素，凡是比 value 大的元素，都向右移动一位，遍历结束后空出来的位置 hole 就是 value 的插入位置。</li><li>外循环： i 可理解为有序部分的数量，同时也是无序部分的首元素的位置。每次外循环 value 都作为无序部分首元素，需通过内循环在有序部分寻找一个合适的位置 hole 并将其插入。</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>选择排序的比较开销是固定的 n(n-1)&#x2F;2,而插入排序平均下来是 n(n-1)&#x2F;4 。 选择排序最多只需要执行 2(n-1)次交换，而插入排序平均的交换开销也是 n(n-1)&#x2F;4 。这就取决于单次比较和交换的开销之比。如果是一个量级的，则插入排序优于选择排序，如果交换开销远大于插入开销，则插入排序可能比选择排序慢。 两两比较，不存在跳跃，所以稳定。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最好情况 O(n)，最坏情况 O(n^2)，平均 O(n^2)。</p><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><h4 id="核心思路-3"><a href="#核心思路-3" class="headerlink" title="核心思路"></a>核心思路</h4><p>在插入排序基础上引入增量 gap 概念，是插入排序的改进。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    var gap = n / 2</span><br><span class="line">    while gap &gt; 0 &#123;</span><br><span class="line">        for i in gap..&lt;n &#123;</span><br><span class="line">            let value = a[i]</span><br><span class="line">            var hole = i</span><br><span class="line">            while hole &gt; 0 &amp;&amp; a[hole-1] &gt; value &#123;</span><br><span class="line">                a[hole] = a[hole-1]</span><br><span class="line">                hole -= 1</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = value</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码讲解-3"><a href="#代码讲解-3" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>当增量 gap 为半数时，在整个数组中选取右边 1&#x2F;2 部分进行插入排序，在此结果上在整个数组中选取右边 3&#x2F;4 部分进行插入排序，反复这个过程，直到最后一次对整个数组做插入排序，最终成为有序数组。 每次做插入排序的部分从 gap 开始，每次扩大做插入排序的范围。</p><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>希尔排序算法 1959 年提出，是直接插入排序算法的一种改进，减少了移动次数，平均时间复杂度比插入快。是第一批时间复杂度低于 O(n^2)的排序算法。 插入排序是稳定的，而 shell 排序会分组，相同的数分在不同的组内各自进行移动打破稳定性。所以不稳定。</p><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>gap &#x2F;&#x3D; 2 表示折半的方式选取增量。究竟应该选取什么样的增量才是最好，目前还有数学上的定论。最坏的情况是 O(n^2)，在使用了增量后，平均时间复杂度 O(n^(3&#x2F;2))。</p><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h2><h4 id="核心思路-4"><a href="#核心思路-4" class="headerlink" title="核心思路"></a>核心思路</h4><p>将数组最右侧的元素作为一个参照值 pivot，以参照值为标准，将数组拆分 patition 为 3 个部分：比参照值小的部分，参照值，比参照值大的部分。 将这个过程再分别应用到较小部分和较大部分中继续拆分，直到所有部分被拆分成 1 个元素无法再拆分，就完成了排序。 这是一个分而治之的方法，也是一个递归的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;, start: Int, end: Int)&#123;</span><br><span class="line">    if start &lt; end &#123;</span><br><span class="line">        let partitionIndex = partition(&amp;a, start: start, end: end)</span><br><span class="line">        sort(&amp;a, start: start, end: partitionIndex-1 )</span><br><span class="line">        sort(&amp;a, start: partitionIndex+1, end: end )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func partition(_ a:inout Array&lt;Int&gt;, start: Int, end: Int) -&gt; Int &#123;</span><br><span class="line">    let pivot = a[end]</span><br><span class="line">    var partitionIndex = start</span><br><span class="line">    for i in start..&lt;end &#123;</span><br><span class="line">        if a[i] &lt;= pivot &#123;</span><br><span class="line">            a.swapAt(i, partitionIndex)</span><br><span class="line">            partitionIndex += 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.swapAt(partitionIndex, end)</span><br><span class="line">    return partitionIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-4"><a href="#代码讲解-4" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>每次递归将数组拆分成前部，基准值，后部 3 部分，前部比后部小。按此方法再递归调用前，后部分，最终达到从小到大的排序。</p><p>partition()拆分 将数组 a 的 start 到 end 区间拆分为三部分。区间内选择一个参照值，通常可选 start 或者 end 的值为参照。因为区间拆分前无序，任何一个值都可作为参照，这里我们选择 end 的值作为参照值 pivot 。 因为 pivot 作为 end ，所以区间遍历使用 i 从 start 到 end-1 ，并假设参照值位置为 pt 初始为 start 。将比参照值小的元素交换到 pt ，pt 的右侧位置就是参照值的位置，所以 pt+&#x3D;1 ，遍历结束，将参照值交换到 pt ，并返回参照值的位置。<br>sort()递归分治 调用 partition()拆分数组，返回拆分后参照值位置 pt ，那么数组前部分的区间是 start 到 pt-1 ，后部分的区间为 pt+1 到 end 。对着两部分继续递归调用 sort()。当数组被拆分为 1 个元素，即 start 等于 end 的时候，则停止分治，退出递归。</p><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>快速排序是一种交换类的排序，它同样是分治法的经典体现。 如果 pivot 的值有重复，pivot 作为参照放在前后两部中间有可能打破稳定性，所以不稳定。</p><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>待排序数组最终被拆分成深度为 logn+1 的二叉树。拆分次数为 logn 。第一次拆分时，总共的执行时间是 Cn(C 为固定的单位时间常数)；第二次拆分时，每个子序列的执行时间为 Cn&#x2F;2 ，总的执行时间是 Cn&#x2F;2+Cn&#x2F;2&#x3D;Cn ；第三次拆分时，总时间时 Cn&#x2F;4+Cn&#x2F;4+Cn&#x2F;4+Cn&#x2F;4+&#x3D;Cn ，所以每次执行复杂度都是 Cn 。 每次执行复杂度 Cn * 拆分次数 log(n) &#x3D; 快排复杂度 O(nlogn)。最坏情况 O(n^2)。</p><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h2><h4 id="核心思路-5"><a href="#核心思路-5" class="headerlink" title="核心思路"></a>核心思路</h4><p>将两个有序数组，合并为一个新的有序数组就是做归并。 归并排序中，将数组从中间分解为左右两部分，将这个过程再应用到左右部分中继续分解。最后把 n 个元素的数组分解为只有 1 个元素的 n 个数组。这种情况下，满足两个有序数组进行的归并条件，开始再两两归并，直到合并出一个新的有序数组就完成了排序。 这是一个分而治之的方法，同时也是一个递归的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func sort(a: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    let n = a.count</span><br><span class="line">    if n == 1 &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    var left = Array(a[0..&lt;n/2])</span><br><span class="line">    var right = Array(a[n/2..&lt;n])</span><br><span class="line">    left = sort(a: left)</span><br><span class="line">    right = sort(a: right)</span><br><span class="line">    let m = merge(left: left, right: right)</span><br><span class="line">    return m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(left: [Int], right: [Int]) -&gt; [Int] &#123;</span><br><span class="line">    var mergedList = [Int]()</span><br><span class="line">    while left.count &gt; 0 &amp;&amp; right.count &gt; 0 &#123;</span><br><span class="line">        if left.first! &lt; right.first! &#123;</span><br><span class="line">            mergedList.append(left.first!)</span><br><span class="line">            left.removeFirst()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mergedList.append(right.first!)</span><br><span class="line">            r.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mergedList + left + right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-5"><a href="#代码讲解-5" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>sort()将数组 a 从中间分为 left 和 right 两部分。再将 left 和 right 再递归调用 sort 继续分解。将分解的结果传入 merge()进行归并。<br>merge()合并 left 和 right 两个有序数组，返回合并后的有序数组。将 left 和 right 两个数组同时开始遍历，对比两个数组的首元素，将较小的元素填入 mergedList ，并在原数组中删除。当遍历结束后，left 或 right 还不为空，说明该数组元素都大于 mergedList ，加入在 mergedList 尾部即可。</p><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p>该算法采用经典的分治（ divide-and-conquer ）策略。分治法将问题分(divide)成一些小的问题然后递归求解。两两比较，不存在跳跃，所以稳定。</p><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>归并排序的效率是比较高的，设数列长为 n ，将数列分开成小数列一共要 logn 步，每步都是一个合并有序数列的过程，时间复杂度可以记为 O(n)，故一共为 O(nlogn)。对空间有要求，空间复杂度 O(n)。所以，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p><h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h2><h4 id="核心思路-6"><a href="#核心思路-6" class="headerlink" title="核心思路"></a>核心思路</h4><p>通过前面元素出现的累计次数确定当前元素的位置，比如第一个元素 1 出现 3 次，那么元素 2 的位置从第 4 个开始，元素 2 出现 4 次，那么元素 3 的位置从第 8 个开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;) &#123;</span><br><span class="line">    let max = a.max() ?? 0</span><br><span class="line">    let min = a.min() ?? 0</span><br><span class="line">    let k = max - min + 1</span><br><span class="line">    var counts = [Int](repeating: 0, count: k)</span><br><span class="line">    for item in a &#123;</span><br><span class="line">        let i =  item - min</span><br><span class="line">        counts[i] += 1</span><br><span class="line">    &#125;</span><br><span class="line">    var prefixSums: [Int] = counts</span><br><span class="line">    for i in 1..&lt;counts.count &#123;</span><br><span class="line">        prefixSums[i] = prefixSums[i - 1] + counts[i]</span><br><span class="line">    &#125;</span><br><span class="line">    var sorted = [Int](repeating: 0, count: a.count)</span><br><span class="line">    for i in 0..&lt;a.count &#123;</span><br><span class="line">        let key = a[i]</span><br><span class="line">        let index = key - min</span><br><span class="line">        let prefixSum = prefixSums[index]</span><br><span class="line">        sorted[prefixSum - 1] = key</span><br><span class="line">        prefixSums[index] -= 1</span><br><span class="line">    &#125;</span><br><span class="line">    a = sorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-6"><a href="#代码讲解-6" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>在无序数组中，先找出最大值 max 和最小值 min ，从而确定需要开辟 max-min+1 大小空间的计数数组和累计数组。</p><p>计数数组： 保存每个元素出现的次数。比如 1 出现 2 次，2 出现 3 次。<br>累计数组： 保存前面元素累计出现的次数。比如，1 出现 3 次，累计 3 次； 2 出现 4 次，累计 3+4&#x3D;7 次； 3 出现 1 次，累计 7+1&#x3D;8 次。累计次数-1 就是元素有序的位置。<br>特点</p><p>计数排序是一个稳定的非比较排序算法。它的优势在于在对一定范围内的整数排序，比如对 1 万名学生的考试分数做排序。计数排序是一种以空间换时间的排序算法，整数大小差异越大，所需要的空间越大。</p><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>计数数组的大小为 k ，无序数组大小为 n ，复杂度为Ο(n+k)，所以时间复杂度是 O(n)；由于申请了大小为 k 的桶来放计数，所以空间复杂度是 O(k)。</p><h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h2><h4 id="核心思路-7"><a href="#核心思路-7" class="headerlink" title="核心思路"></a>核心思路</h4><p>是一种非比较的整数排序算法。其原理是将整数按位数切割成不同的数字，然后对每个位数上的数字进行分别比较。第一轮先按个位数大小排序，第二轮按十位数大小排序，一直进行到最高位。实际上是也一种桶排序，从 0 到 9 一共分 10 个桶。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">    let maxValue = a.max() ?? 0</span><br><span class="line">    var buckets = [[Int]](repeating: [], count: 10)</span><br><span class="line">    var powerOfTen = 1</span><br><span class="line">    while maxValue / powerOfTen &gt; 0 &#123;</span><br><span class="line">        a = a.compactMap &#123; value in</span><br><span class="line">            buckets[value / powerOfTen % 10].append(value)</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        buckets = buckets.map &#123; bucket in</span><br><span class="line">            bucket.forEach &#123; value in</span><br><span class="line">                a.append(value)</span><br><span class="line">            &#125;</span><br><span class="line">            return []</span><br><span class="line">        &#125;</span><br><span class="line">        powerOfTen *= 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-7"><a href="#代码讲解-7" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>先找到最大数，算出最大数有几位，则进行几次桶排序。 powerOfTen 初始为 1 ，每次 while 循环则乘以 10 倍，这样 while 循环的次数就是最大数的位数。 10 个桶，当进行个位数比较的时候，桶 n 保存个位为 n 的元素，当进行十位数比较的时候，桶 n 保存十位为 n 的元素。</p><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>是一种非比较的稳定的整数排序算法。 不适用于数字的位数 k 多，但是排序的数少的情况； 适用于数字小但是排序的数字多的情况。</p><h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>复杂度是 O(n*k)。其中 n 是排序元素个数，每轮处理的操作数目； k 是数字位数，决定了进行多少轮处理。 并不一定优于 O(n·logn)，当 k&gt;logn ，就没有归并、堆排序快。</p><h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h2><h4 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h4><p>完全二叉树：其每个结点的编号跟满二叉树都能一一对应。<br>堆：是一个完全二叉树，其每个结点的值都大于等于其子结点的值称为大顶堆。<br>满二叉树：所有分支结点都有左右子结点，所有子结点都在同一层上。</p><h4 id="核心思路-8"><a href="#核心思路-8" class="headerlink" title="核心思路"></a>核心思路</h4><p>大顶堆的顶是最大的，所以堆排序的过程就是反复的构造堆。 第一次构建的堆顶最大，和堆尾交换放在数组最后一位，第二次构建的堆的堆顶第二大，放在倒数第二位，以此类推进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ a:inout Array&lt;Int&gt;)&#123;</span><br><span class="line">	// 构建初始堆</span><br><span class="line">    createHeap(a: &amp;a)</span><br><span class="line">    // 重建堆。逆序遍历反复构建大顶堆，遍历一次，顶被摘掉放入结果数组 a 尾部，直到最后无法构建堆，结果就是有序数组 a</span><br><span class="line">    for index in a.indices.reversed() &#123;</span><br><span class="line">        siftDown(from: 0, upTo: index, a: &amp;a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createHeap(a:inout Array&lt;Int&gt;) &#123;</span><br><span class="line">    if !a.isEmpty &#123;</span><br><span class="line">        //从 a.count/2 - 1 开始到 0 结束，逆序遍历。a.count/2 - 1 是第一个非叶子节点，向根部遍历</span><br><span class="line">        for i in stride(from: a.count/2 - 1, through: 0, by: -1) &#123;</span><br><span class="line">            siftDown(from: i, upTo: a.count, a: &amp;a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func siftDown(from index: Int, upTo size: Int, a:inout Array&lt;Int&gt;) &#123;</span><br><span class="line">    var parent = index</span><br><span class="line">    while true &#123;</span><br><span class="line">        let left = a[leftChildIndex(ofParentAt: parent)]</span><br><span class="line">        let right = a[rightChildIndex(ofParentAt: parent)]</span><br><span class="line">        var candidate = parent</span><br><span class="line">        if left &lt; size &amp;&amp; a[left] &gt; a[candidate] &#123;</span><br><span class="line">            candidate = left</span><br><span class="line">        &#125;</span><br><span class="line">        if right &lt; size &amp;&amp; a[right] &gt; a[candidate] &#123;</span><br><span class="line">            candidate = right</span><br><span class="line">        &#125;</span><br><span class="line">        if candidate == parent &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        a.swapAt(parent, candidate)</span><br><span class="line">        parent = candidate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在树的顺序存储中，返回 i 的左子节点的下标</span><br><span class="line">func leftChildIndex(ofParentAt i: Int) -&gt; Int &#123;</span><br><span class="line">    return (2 * i) + 1</span><br><span class="line">&#125;</span><br><span class="line">// 在树的顺序存储中，返回 i 的右子节点的下标</span><br><span class="line">func rightChildIndex(ofParentAt i: Int) -&gt; Int &#123;</span><br><span class="line">    return (2 * i) + 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码讲解-8"><a href="#代码讲解-8" class="headerlink" title="代码讲解"></a>代码讲解</h4><p>先构建堆，可以是大顶堆（也可以是小顶堆）。交换堆顶[0]元素（堆中最大）与末尾[index]元素，再将[0 ，–index]的堆调整为大顶堆。重复到 index 为 0 。</p><h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><p>堆尾如果有重复，被交换到数组首再构建堆，会打破稳定性，所以不稳定（记录的比较和交换是跳跃式进行的）。</p><h4 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>整体主要由构建初始堆和重建堆两部分组成。其中构建初始堆经推导复杂度为 O(n)，在交换并重建堆的过程中，需交换 n-1 次；而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为 nlogn 。所以堆排序时间复杂度一般认为就是 O(nlogn)级。，空间复杂度是 O(1)。</p></div></article><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a href="/archives/">归档</a></li><li><a href="/">项目</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%80%E8%A7%88"><span class="toc-number">1.0.1.</span> <span class="toc-text">排序的复杂度一览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-time-complexity"><span class="toc-number">1.0.2.</span> <span class="toc-text">时间复杂度(time complexity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Space-Complexity"><span class="toc-number">1.0.3.</span> <span class="toc-text">空间复杂度(Space Complexity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.0.4.</span> <span class="toc-text">排序的稳定性</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="toc-number">2.</span> <span class="toc-text">冒泡排序(Bubble Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">2.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort"><span class="toc-number">3.</span> <span class="toc-text">选择排序(Selection Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-1"><span class="toc-number">3.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">3.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">3.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="toc-number">4.</span> <span class="toc-text">插入排序(Insertion Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-2"><span class="toc-number">4.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">4.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">4.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shell-Sort"><span class="toc-number">5.</span> <span class="toc-text">希尔排序(Shell Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-3"><span class="toc-number">5.0.1.</span> <span class="toc-text">核心思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-3"><span class="toc-number">5.1.</span> <span class="toc-text">代码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">5.1.1.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="toc-number">6.</span> <span class="toc-text">快速排序(Quick Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-4"><span class="toc-number">6.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-4"><span class="toc-number">6.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">6.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">6.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="toc-number">7.</span> <span class="toc-text">归并排序(Merge Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-5"><span class="toc-number">7.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-5"><span class="toc-number">7.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">7.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-number">7.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-Counting-Sort"><span class="toc-number">8.</span> <span class="toc-text">计数排序(Counting Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-6"><span class="toc-number">8.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-6"><span class="toc-number">8.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-number">8.0.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="toc-number">9.</span> <span class="toc-text">基数排序(Radix Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-7"><span class="toc-number">9.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-7"><span class="toc-number">9.0.2.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-number">9.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="toc-number">9.0.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="toc-number">10.</span> <span class="toc-text">堆排序(Heap Sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">10.0.1.</span> <span class="toc-text">相关概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF-8"><span class="toc-number">10.0.2.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-8"><span class="toc-number">10.0.3.</span> <span class="toc-text">代码讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-7"><span class="toc-number">10.0.4.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="toc-number">10.0.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></div><div id="share-footer" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&text=九大经典排序算法[转]"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&is_video=false&description=九大经典排序算法[转]"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=九大经典排序算法[转]&body=Check out this article: https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&title=九大经典排序算法[转]"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&name=九大经典排序算法[转]&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/&t=九大经典排序算法[转]"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2023 LuckyEast</div><div class="footer-right"><nav><ul><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a href="/archives/">归档</a></li><li><a href="/">项目</a></li></ul></nav></div></footer></div><link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload='this.onload=null,this.rel="stylesheet"'><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script><script type="text/javascript">$(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })</script><script src="/js/main.js"></script></body></html>