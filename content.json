{"meta":{"title":"Hello world","subtitle":"","description":"","author":"LuckyEast","url":"https://luckyeast.eu.org","root":"/"},"pages":[{"title":"Untitled","date":"2023-11-02T19:52:53.000Z","updated":"2023-11-03T03:52:53.396Z","comments":true,"path":"Untitled/index.html","permalink":"https://luckyeast.eu.org/Untitled/index.html","excerpt":"","text":""},{"title":"自嘲","date":"2023-11-02T18:26:24.000Z","updated":"2023-11-03T03:53:03.296Z","comments":true,"path":"about/index.html","permalink":"https://luckyeast.eu.org/about/index.html","excerpt":"","text":"自嘲陆游〔宋代〕 陆游（1125年11月13日－1210年1月26日），字务观，号放翁，汉族，越州山阴（今浙江绍兴）人，尚书右丞陆佃之孙，南宋文学家、史学家、爱国诗人。 少读诗书陋汉唐，莫年身世寄农桑。 骑驴两脚欲到地，爱酒一樽常在旁。 老去形容虽变改，醉来意气尚轩昂。 太行王屋何由动，堪笑愚公不自量。 译文少年时候读诗书，连汉唐的武功也不放在眼里，到老却寄身农桑。骑在驴身上两脚快要到地，喜爱喝酒，酒杯常在身旁。老去以后容貌虽然变改，醉了以后意气仍然轩昂。太行王屋两座山究竟是怎么被移动的？可笑我自己就像愚公一样不自量。"}],"posts":[{"title":"九大经典排序算法[转]","slug":"九大经典排序算法-转","date":"2023-11-03T05:47:32.000Z","updated":"2023-11-03T06:11:29.779Z","comments":true,"path":"2023/11/03/九大经典排序算法-转/","permalink":"https://luckyeast.eu.org/2023/11/03/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC/","excerpt":"","text":"概述排序的复杂度一览 算法 时间复杂度:最好 时间复杂度:平均 时间复杂度:最坏 空间复杂度:最坏 稳定性 冒泡排序 O(n) O(n^2) O(n^2) O(1) 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 插入排序 O(n) O(n^2) O(n^2) O(1) 稳定 希尔排序 O(n) O(n^3&#x2F;2) O(n^2) O(1) 不稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) 稳定 基数排序 O(nk) O(nk) O(nk) O(n+k) 稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 时间复杂度(time complexity)用来描述算法的运行时间。常用大 O 符号表述。比如：O(n)，O(1)，O(logn)，O(n^2)等。举例： O(n)表示线性级复杂度，表示时间复杂度和元素 element 数量 n 成正比。比如数组的线性查找的复杂度随着元素数量增加而增加。 O(1)表示常数级复杂度，表示时间复杂度不随元素 element 数量变化而变化。比如链表的插入的复杂度不随链表节点数量变化而变化。 其他常见的复杂度如下图所示： 空间复杂度(Space Complexity)对一个算法在运行过程中临时占用存储空间大小的量度。也可用大 O 符号表述。举例： O(n)表示线性级复杂度，表示算法所需空间大小和元素数量成正比，比如归并排序，需要额外的临时空间来保存两个数组的合并结果，元素越多所需空间越大。 O(n)表示常数级复杂度，表示算法所需空间大小和元素数量无关。 排序的稳定性稳定：相等的两个数，排序前后两数的顺序保持不变。不稳定：相等的两个数，排序前后两数的顺序发生变化。 冒泡排序(Bubble Sort)核心思路将数组分为左右两部分，左为无序部分，右为有序部分。无序部分中的最大数在每次遍历结束后被交换到无序部分的最右侧，继而成为有序部分的最左侧元素，就像冒泡一样。 123456789101112131415func sort(_ a:inout Array&lt;Int&gt;)&#123; let n = a.count for i in 0..&lt;n-1 &#123; var isSorted = true for j in 0..&lt;n-1-i &#123; if a[j] &gt; a[j+1] &#123; a.swapAt(j, j+1) isSorted = false &#125; &#125; if isSorted &#123; break &#125; &#125;&#125; 代码讲解使用双重循来遍历，把双重循环分为内循环和外循环。 内循环： 从左往右处理无序部分，使用下标 j 遍历，比较相邻元素大小，交换位置成为左小右大，一次遍历后，无序部分中最大数被交换到无序部分的最右处，继而加入有序部分的最左侧。 外循环： i 可理解为有序部分的数量，每次内循环结束，有序部分数量增加一个，无序部分数量减少一个。 特点两两比较，不存在跳跃，所以稳定。 每次遍历都能检查数组是否有序，可提前退出排序，但是冒泡的交换在内循环，交换次数多。实际效率比选择排序低。 复杂度分析最好的情况可以达到 O(n)，最坏的情况是 O(n^2)，平均 O(n^2)。 选择排序(Selection Sort)核心思路将数组分为左右两部分，左为有序部分，右为无序部分。无序部分每次遍历选择出一个最小的元素，交换到无序部分的最左侧，继而成为有序部分的最右侧元素。 123456789101112func sort(_ a:inout Array&lt;Int&gt;)&#123; let n = a.count for i in 0..&lt;n-1 &#123; var iMin = i for j in i+1..&lt;n &#123; if a[iMin] &gt; a[j] &#123; iMin = j &#125; &#125; a.swapAt(i, iMin) &#125;&#125; 代码讲解使用双重循来遍历，把双重循环分为内循环和外循环。 内循环： 从左往右处理无序部分，使用下标 j 遍历，每次遍历后保存下无序部分中最小数的位置 iMin 。 外循环： i 为无序部分的首元素位置，其左侧为有序部分，将有序部分排除在内循环外。每次内循环结束，将内循环保存的 iMin 和 i 位置的连个元素交换，使有序部分数量增加一个，无序部分数量减少一个。 特点由于交换动作放在外循环，交换次数少于冒泡，实际效率优于冒泡。除非本来就是有序的数组的最好情况，选择排序还是要进行比较和交换，而冒泡排序一次 n 的遍历就能提前退出。 不稳定，举个例子，序列 5 8 5 2 9 ， 我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了） 复杂度分析最好情况 O(n^2)，最坏情况 O(n^2)，平均 O(n^2)。 插入排序(Insertion Sort)核心思路将数组分为左右两部分，左为有序部分，右为无序部分。遍历有序部分，将无序部分首元素，根据其大小在有序部分寻找合适的位置并插入。 12345678910111213func sort(_ a:inout Array&lt;Int&gt;)&#123; let n = a.count for i in 1..&lt;n &#123; print(&quot; i=\\(i)&quot;) let value = a[i] var hole = i while hole &gt; 0 &amp;&amp; a[hole-1] &gt; value &#123; a[hole] = a[hole-1] hole -= 1 &#125; a[hole] = value &#125;&#125; 代码讲解使用双重循来遍历，把双重循环分为内循环和外循环。 内循环： 每次从无序部分的首元素 value 的位置开始，从右向左，在有序部分中遍历，比较每一个元素，凡是比 value 大的元素，都向右移动一位，遍历结束后空出来的位置 hole 就是 value 的插入位置。 外循环： i 可理解为有序部分的数量，同时也是无序部分的首元素的位置。每次外循环 value 都作为无序部分首元素，需通过内循环在有序部分寻找一个合适的位置 hole 并将其插入。 特点选择排序的比较开销是固定的 n(n-1)&#x2F;2,而插入排序平均下来是 n(n-1)&#x2F;4 。 选择排序最多只需要执行 2(n-1)次交换，而插入排序平均的交换开销也是 n(n-1)&#x2F;4 。这就取决于单次比较和交换的开销之比。如果是一个量级的，则插入排序优于选择排序，如果交换开销远大于插入开销，则插入排序可能比选择排序慢。 两两比较，不存在跳跃，所以稳定。 复杂度分析最好情况 O(n)，最坏情况 O(n^2)，平均 O(n^2)。 希尔排序(Shell Sort)核心思路在插入排序基础上引入增量 gap 概念，是插入排序的改进。 12345678910111213141516func sort(_ a:inout Array&lt;Int&gt;)&#123; let n = a.count var gap = n / 2 while gap &gt; 0 &#123; for i in gap..&lt;n &#123; let value = a[i] var hole = i while hole &gt; 0 &amp;&amp; a[hole-1] &gt; value &#123; a[hole] = a[hole-1] hole -= 1 &#125; a[hole] = value &#125; gap /= 2 &#125;&#125; 代码讲解当增量 gap 为半数时，在整个数组中选取右边 1&#x2F;2 部分进行插入排序，在此结果上在整个数组中选取右边 3&#x2F;4 部分进行插入排序，反复这个过程，直到最后一次对整个数组做插入排序，最终成为有序数组。 每次做插入排序的部分从 gap 开始，每次扩大做插入排序的范围。 特点希尔排序算法 1959 年提出，是直接插入排序算法的一种改进，减少了移动次数，平均时间复杂度比插入快。是第一批时间复杂度低于 O(n^2)的排序算法。 插入排序是稳定的，而 shell 排序会分组，相同的数分在不同的组内各自进行移动打破稳定性。所以不稳定。 复杂度分析gap &#x2F;&#x3D; 2 表示折半的方式选取增量。究竟应该选取什么样的增量才是最好，目前还有数学上的定论。最坏的情况是 O(n^2)，在使用了增量后，平均时间复杂度 O(n^(3&#x2F;2))。 快速排序(Quick Sort)核心思路将数组最右侧的元素作为一个参照值 pivot，以参照值为标准，将数组拆分 patition 为 3 个部分：比参照值小的部分，参照值，比参照值大的部分。 将这个过程再分别应用到较小部分和较大部分中继续拆分，直到所有部分被拆分成 1 个元素无法再拆分，就完成了排序。 这是一个分而治之的方法，也是一个递归的过程。 1234567891011121314151617181920func sort(_ a:inout Array&lt;Int&gt;, start: Int, end: Int)&#123; if start &lt; end &#123; let partitionIndex = partition(&amp;a, start: start, end: end) sort(&amp;a, start: start, end: partitionIndex-1 ) sort(&amp;a, start: partitionIndex+1, end: end ) &#125;&#125; func partition(_ a:inout Array&lt;Int&gt;, start: Int, end: Int) -&gt; Int &#123; let pivot = a[end] var partitionIndex = start for i in start..&lt;end &#123; if a[i] &lt;= pivot &#123; a.swapAt(i, partitionIndex) partitionIndex += 1 &#125; &#125; a.swapAt(partitionIndex, end) return partitionIndex&#125; 代码讲解每次递归将数组拆分成前部，基准值，后部 3 部分，前部比后部小。按此方法再递归调用前，后部分，最终达到从小到大的排序。 partition()拆分 将数组 a 的 start 到 end 区间拆分为三部分。区间内选择一个参照值，通常可选 start 或者 end 的值为参照。因为区间拆分前无序，任何一个值都可作为参照，这里我们选择 end 的值作为参照值 pivot 。 因为 pivot 作为 end ，所以区间遍历使用 i 从 start 到 end-1 ，并假设参照值位置为 pt 初始为 start 。将比参照值小的元素交换到 pt ，pt 的右侧位置就是参照值的位置，所以 pt+&#x3D;1 ，遍历结束，将参照值交换到 pt ，并返回参照值的位置。sort()递归分治 调用 partition()拆分数组，返回拆分后参照值位置 pt ，那么数组前部分的区间是 start 到 pt-1 ，后部分的区间为 pt+1 到 end 。对着两部分继续递归调用 sort()。当数组被拆分为 1 个元素，即 start 等于 end 的时候，则停止分治，退出递归。 特点快速排序是一种交换类的排序，它同样是分治法的经典体现。 如果 pivot 的值有重复，pivot 作为参照放在前后两部中间有可能打破稳定性，所以不稳定。 复杂度分析待排序数组最终被拆分成深度为 logn+1 的二叉树。拆分次数为 logn 。第一次拆分时，总共的执行时间是 Cn(C 为固定的单位时间常数)；第二次拆分时，每个子序列的执行时间为 Cn&#x2F;2 ，总的执行时间是 Cn&#x2F;2+Cn&#x2F;2&#x3D;Cn ；第三次拆分时，总时间时 Cn&#x2F;4+Cn&#x2F;4+Cn&#x2F;4+Cn&#x2F;4+&#x3D;Cn ，所以每次执行复杂度都是 Cn 。 每次执行复杂度 Cn * 拆分次数 log(n) &#x3D; 快排复杂度 O(nlogn)。最坏情况 O(n^2)。 归并排序(Merge Sort)核心思路将两个有序数组，合并为一个新的有序数组就是做归并。 归并排序中，将数组从中间分解为左右两部分，将这个过程再应用到左右部分中继续分解。最后把 n 个元素的数组分解为只有 1 个元素的 n 个数组。这种情况下，满足两个有序数组进行的归并条件，开始再两两归并，直到合并出一个新的有序数组就完成了排序。 这是一个分而治之的方法，同时也是一个递归的过程。 1234567891011121314151617181920212223242526func sort(a: [Int]) -&gt; [Int] &#123; let n = a.count if n == 1 &#123; return a &#125; var left = Array(a[0..&lt;n/2]) var right = Array(a[n/2..&lt;n]) left = sort(a: left) right = sort(a: right) let m = merge(left: left, right: right) return m&#125;func merge(left: [Int], right: [Int]) -&gt; [Int] &#123; var mergedList = [Int]() while left.count &gt; 0 &amp;&amp; right.count &gt; 0 &#123; if left.first! &lt; right.first! &#123; mergedList.append(left.first!) left.removeFirst() &#125; else &#123; mergedList.append(right.first!) r.removeFirst() &#125; &#125; return mergedList + left + right&#125; 代码讲解sort()将数组 a 从中间分为 left 和 right 两部分。再将 left 和 right 再递归调用 sort 继续分解。将分解的结果传入 merge()进行归并。merge()合并 left 和 right 两个有序数组，返回合并后的有序数组。将 left 和 right 两个数组同时开始遍历，对比两个数组的首元素，将较小的元素填入 mergedList ，并在原数组中删除。当遍历结束后，left 或 right 还不为空，说明该数组元素都大于 mergedList ，加入在 mergedList 尾部即可。 特点该算法采用经典的分治（ divide-and-conquer ）策略。分治法将问题分(divide)成一些小的问题然后递归求解。两两比较，不存在跳跃，所以稳定。 复杂度分析归并排序的效率是比较高的，设数列长为 n ，将数列分开成小数列一共要 logn 步，每步都是一个合并有序数列的过程，时间复杂度可以记为 O(n)，故一共为 O(nlogn)。对空间有要求，空间复杂度 O(n)。所以，归并排序是一种比较占用内存，但却效率高且稳定的算法。 计数排序(Counting Sort)核心思路通过前面元素出现的累计次数确定当前元素的位置，比如第一个元素 1 出现 3 次，那么元素 2 的位置从第 4 个开始，元素 2 出现 4 次，那么元素 3 的位置从第 8 个开始。 1234567891011121314151617181920212223func sort(_ a:inout Array&lt;Int&gt;) &#123; let max = a.max() ?? 0 let min = a.min() ?? 0 let k = max - min + 1 var counts = [Int](repeating: 0, count: k) for item in a &#123; let i = item - min counts[i] += 1 &#125; var prefixSums: [Int] = counts for i in 1..&lt;counts.count &#123; prefixSums[i] = prefixSums[i - 1] + counts[i] &#125; var sorted = [Int](repeating: 0, count: a.count) for i in 0..&lt;a.count &#123; let key = a[i] let index = key - min let prefixSum = prefixSums[index] sorted[prefixSum - 1] = key prefixSums[index] -= 1 &#125; a = sorted&#125; 代码讲解在无序数组中，先找出最大值 max 和最小值 min ，从而确定需要开辟 max-min+1 大小空间的计数数组和累计数组。 计数数组： 保存每个元素出现的次数。比如 1 出现 2 次，2 出现 3 次。累计数组： 保存前面元素累计出现的次数。比如，1 出现 3 次，累计 3 次； 2 出现 4 次，累计 3+4&#x3D;7 次； 3 出现 1 次，累计 7+1&#x3D;8 次。累计次数-1 就是元素有序的位置。特点 计数排序是一个稳定的非比较排序算法。它的优势在于在对一定范围内的整数排序，比如对 1 万名学生的考试分数做排序。计数排序是一种以空间换时间的排序算法，整数大小差异越大，所需要的空间越大。 复杂度分析计数数组的大小为 k ，无序数组大小为 n ，复杂度为Ο(n+k)，所以时间复杂度是 O(n)；由于申请了大小为 k 的桶来放计数，所以空间复杂度是 O(k)。 基数排序(Radix Sort)核心思路是一种非比较的整数排序算法。其原理是将整数按位数切割成不同的数字，然后对每个位数上的数字进行分别比较。第一轮先按个位数大小排序，第二轮按十位数大小排序，一直进行到最高位。实际上是也一种桶排序，从 0 到 9 一共分 10 个桶。 123456789101112131415161718func sort(_ a:inout Array&lt;Int&gt;)&#123; let maxValue = a.max() ?? 0 var buckets = [[Int]](repeating: [], count: 10) var powerOfTen = 1 while maxValue / powerOfTen &gt; 0 &#123; a = a.compactMap &#123; value in buckets[value / powerOfTen % 10].append(value) return nil &#125; buckets = buckets.map &#123; bucket in bucket.forEach &#123; value in a.append(value) &#125; return [] &#125; powerOfTen *= 10 &#125;&#125; 代码讲解先找到最大数，算出最大数有几位，则进行几次桶排序。 powerOfTen 初始为 1 ，每次 while 循环则乘以 10 倍，这样 while 循环的次数就是最大数的位数。 10 个桶，当进行个位数比较的时候，桶 n 保存个位为 n 的元素，当进行十位数比较的时候，桶 n 保存十位为 n 的元素。 特点是一种非比较的稳定的整数排序算法。 不适用于数字的位数 k 多，但是排序的数少的情况； 适用于数字小但是排序的数字多的情况。 复杂度分析复杂度是 O(n*k)。其中 n 是排序元素个数，每轮处理的操作数目； k 是数字位数，决定了进行多少轮处理。 并不一定优于 O(n·logn)，当 k&gt;logn ，就没有归并、堆排序快。 堆排序(Heap Sort)相关概念：完全二叉树：其每个结点的编号跟满二叉树都能一一对应。堆：是一个完全二叉树，其每个结点的值都大于等于其子结点的值称为大顶堆。满二叉树：所有分支结点都有左右子结点，所有子结点都在同一层上。 核心思路大顶堆的顶是最大的，所以堆排序的过程就是反复的构造堆。 第一次构建的堆顶最大，和堆尾交换放在数组最后一位，第二次构建的堆的堆顶第二大，放在倒数第二位，以此类推进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445func sort(_ a:inout Array&lt;Int&gt;)&#123; // 构建初始堆 createHeap(a: &amp;a) // 重建堆。逆序遍历反复构建大顶堆，遍历一次，顶被摘掉放入结果数组 a 尾部，直到最后无法构建堆，结果就是有序数组 a for index in a.indices.reversed() &#123; siftDown(from: 0, upTo: index, a: &amp;a) &#125;&#125;func createHeap(a:inout Array&lt;Int&gt;) &#123; if !a.isEmpty &#123; //从 a.count/2 - 1 开始到 0 结束，逆序遍历。a.count/2 - 1 是第一个非叶子节点，向根部遍历 for i in stride(from: a.count/2 - 1, through: 0, by: -1) &#123; siftDown(from: i, upTo: a.count, a: &amp;a) &#125; &#125;&#125;func siftDown(from index: Int, upTo size: Int, a:inout Array&lt;Int&gt;) &#123; var parent = index while true &#123; let left = a[leftChildIndex(ofParentAt: parent)] let right = a[rightChildIndex(ofParentAt: parent)] var candidate = parent if left &lt; size &amp;&amp; a[left] &gt; a[candidate] &#123; candidate = left &#125; if right &lt; size &amp;&amp; a[right] &gt; a[candidate] &#123; candidate = right &#125; if candidate == parent &#123; return &#125; a.swapAt(parent, candidate) parent = candidate &#125;&#125;// 在树的顺序存储中，返回 i 的左子节点的下标func leftChildIndex(ofParentAt i: Int) -&gt; Int &#123; return (2 * i) + 1&#125;// 在树的顺序存储中，返回 i 的右子节点的下标func rightChildIndex(ofParentAt i: Int) -&gt; Int &#123; return (2 * i) + 2&#125; 代码讲解先构建堆，可以是大顶堆（也可以是小顶堆）。交换堆顶[0]元素（堆中最大）与末尾[index]元素，再将[0 ，–index]的堆调整为大顶堆。重复到 index 为 0 。 特点堆尾如果有重复，被交换到数组首再构建堆，会打破稳定性，所以不稳定（记录的比较和交换是跳跃式进行的）。 复杂度分析整体主要由构建初始堆和重建堆两部分组成。其中构建初始堆经推导复杂度为 O(n)，在交换并重建堆的过程中，需交换 n-1 次；而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为 nlogn 。所以堆排序时间复杂度一般认为就是 O(nlogn)级。，空间复杂度是 O(1)。","categories":[],"tags":[],"author":"LuckyEast"},{"title":"Linux下开机添加Hosts记录","slug":"Linux下开机添加Hosts记录","date":"2023-11-02T10:28:00.000Z","updated":"2023-11-03T03:19:19.311Z","comments":true,"path":"2023/11/02/Linux下开机添加Hosts记录/","permalink":"https://luckyeast.eu.org/2023/11/02/Linux%E4%B8%8B%E5%BC%80%E6%9C%BA%E6%B7%BB%E5%8A%A0Hosts%E8%AE%B0%E5%BD%95/","excerpt":"","text":"编辑.bashrc文件,添加一下内容：123sudo sed -i &#x27;/# ING Hosts Start/,/# ING Hosts End/d&#x27; /etc/hosts #删除记录curl -s -k -L https://raw.githubusercontent.com/wjz304/hosts/main/hosts | sudo tee -a /etc/hosts #添加记录 执行source ~&#x2F;.bashrc，使修改生效；或者断开连接重新登录。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://luckyeast.eu.org/tags/Linux/"}],"author":"LuckyEast"}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://luckyeast.eu.org/tags/Linux/"}]}